{
  "name": "syncwrap",
  "description": "Yet another library for managing async calls on node",
  "keywords": [
    "async",
    "sync",
    "control",
    "flow"
  ],
  "homepage": "https://github.com/like-falling-leaves/syncwrap",
  "bugs": {
    "url": "https://github.com/like-falling-leaves/syncwrap/issues"
  },
  "license": "MIT",
  "author": {
    "name": "Like FallingLeaves",
    "email": "likefallingleaves@gmail.com"
  },
  "main": "./wrap.js",
  "maintainers": [
    {
      "name": "Like FallingLeaves",
      "email": "likefallingleaves@gmail.com"
    }
  ],
  "version": "0.0.10",
  "repository": {
    "type": "git",
    "url": "git://github.com/like-falling-leaves/syncwrap.git"
  },
  "readmeFilename": "README.md",
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.*",
    "lazy.js": "~0.3.0"
  },
  "scripts": {
    "test": "mocha test/"
  },
  "readme": "# syncwrap\n\nThis is yet another module to help manage async libraries.  There are a few differences between this and other modules:\n\n* Promises are evaluated lazily.\n* Non-invasive, non-infectious: promises can be passed to functions that are not aware of promises and the fundamental style of programming does not need to change. No reason to also use complex flow control mechanisms that pervade all the code -- instead most functions continue to be written like before with very localized uses of this library.\n* Very tiny footprint.  The module is about a 100 lines now.\n* Nice syntactic sugar with use of Function.prototype to expose the wrapped methods on any function.\n\nSome other details (which other flow-control libraries may share):\n\n* All callbacks are expected to be node-style two parameter contracts.\n* If the result of a promise evaluation is another promise, it will be evaluated as well.  Arguments to any wrapped function can be promises and the function is only evaluated after the promises are delivered.\n\n\n[![NPM info](https://nodei.co/npm/syncwrap.png?downloads=true)](https://npmjs.org/package/syncwrap)\n\n[![Travis build status](https://api.travis-ci.org/Like-Falling-Leaves/syncwrap.png?branch=master)](\nhttps://travis-ci.org/Like-Falling-Leaves/syncwrap)\n\n## TODO\n\nThis document is pretty sketchy. You can look at the unit tests to see more details.\n\n## Install on Node\n\n   npm install syncwrap\n\n## Install on browser\n\n   The module has no dependencies and should theoretically work on browsers but it has not been adapted to make this easy yet.\n\n## API\n\n   It is best to read the unit tests under test directory to understand how to use this.  The API is still under flux.\n\n   All the examples assume the following functions:\n\n```javascript\n\nvar wrap = require('syncwrap');\nvar assert = require('assert');\n\nfunction test(x, y, done) { return done(null, x + y); }\nfunction testFail(x, y, done) { return done('Failed'); }\nfunction testSync(x, y) { return x + y; }\nfunction join(x, y, z) { return [x, y, z].join(' '); }\n\n```\n\n### Example #1: Calling a series of async functions.\n\n```javascript\n\n  var wrapped = test.wrap(5,\n    test.wrap(4,\n      test.wrap(3, 2)\n    )\n  );\n\n  // because of lazy evaluation, none of the above functions are executed yet.\n  // but with the next statement, they *all* will be.\n  wrapped().done(function (err, val) {\n    assert.ok(!err);\n    assert.equal(val, 5 + 4 + 3 + 2);\n  });\n\n  // Notice also that the callback can be *before* or *after* the call to wrapped.\n  wrapped.done(function (err, val) {\n    assert.ok(!err);\n    assert.equal(val, 5 + 4 + 3 + 2);\n  })();\n\n```\n\n### Example #2: Failure handling\n\n```javascript\n\n  // failure handling can be done either via .fail which only gets called on failures\n  testFail.wrapped(5, 3)\n    .fail(function (err) { assert.equal(err, 'Failed'); });\n\n  // Or, failures can be obtained via just done which gets called success or failure.\n  testFail.wrapped(5, 3)\n    .done(function (err) { assert.equal(err, 'Failed'); });\n\n  // Failures can also be suppressed via errorValue which has the effect of replacing the \n  // value of the return on error to the one provided\n  testFail.wrapped(5, 3)\n    .failValue(23)\n    .done(function (err, val) { assert.ok(!err); assert.equal(val, 23); })  \n\n  // Similar mechanism also exists for changing the success value. It is also possible\n  // to provide a promise to an error value in which case that promise will be evaluated\n  // for the error code path and used.\n  testFail.wrapped(5, 3)\n    .failValue(test.wrapped(22, 11))\n    .done(function (err, val) { assert.ok(!err); assert.equal(val, 33); })  \n\n```\n\n### Example #3: Sync functions\n\n```javascript\n\n  // if sync functions need to work on promises, it is useful to call the wrapped version which\n  // can deal with this\n  testSync.wrapped(test.wrapped(5,5), test.wrapped(3,3))\n    .sync(true)\n    .done(function (err, val) { assert.ok(!err); assert.equal(val, 16); });\n\n  // Occasionally, you want the promise to be evaluated but if the promises fail, to not \n  // fail the whole call.  So, use ignoreErrors then (or use failValue)\n  join.wrapped(testFail.wrapped(5,5).ignoreErrors(true), test.wrapped(3,3), 22)\n    .sync(true)\n    .done(function (err, val) { assert.ok(!err); assert.equal(val, ' 6 22'); });\n```\n\n### Example #4: Unwrapping\n\n```javascript\n\n  // it is sometimes useful to evaluate a bunch of promises in parallel and get the results.\n  // unwrap is internally used to evaluate the parameters for any function that was wrapped.\n\n  wrap.unwrap([test.wrapped(5,5), testSync.wrapped(3,3).sync(true)])\n    .done(function (err, val) { \n      expect.ok(!err); assert.equal(val[0], 10); assert.equal(val[1], 6); \n    });  \n```\n\n### Other features\n\nThe wrapped method unfortunately does not have an associated 'context'.  So, if your underlying function expects to use the 'this' parameter, this needs to be explicitly bound by using the following mechanism:\n\n```javascript\n\n   wrapped = test.wrapped.set({context: context})(args);\n   // or\n   wrapped = wrap(test, context)(args);\n```\n\nNote that the context passed itself can be a promise which is useful for a scenario where the user object must be fetched and some instance method called:\n\n```javascript\n   function getHotels(userId, distance, done) {\n     User.prototype.getHotels.wrap(distance)\n       .set({context: getUserFromId.wrapped(userId)})\n       .done(done)\n     ();\n   }\n\n   // instead of:\n   function getHotels(userId, distance, done) {\n     getUserFromId(userId, function (err, user) {\n       if (err) return done(err);\n       user.getHotels(distance, done);       \n     });\n   }\n\n   // if you don't have access to the method via the prototype, you can still do this:\n   // use a string as a function name and it will assume the function name is a property\n   // of the context\n   function getHotels(userId, distance, done) {\n     wrap('getHotels', getUserFromId.wrapped(userId), [distance])\n       .done(done)\n     ();\n   }\n\n```\n\nIt is possible to have multiple callbacks passed via done and fail by calling them repeatedly.\n\nThere is no built-in support for serial execution of async functions but that isn't hard to do:\n\n```javascript\n\n   var funcs = [func1, func2, func3];\n   serialize(funcs, done);\n\n   function serialize(funcs, done) {\n     var next = funcs.shift();\n     if (!next) return done();\n     next.wrapped().done(function () { serialize(funcs, done); });\n   }\n```\n\nAn alternate way is to rely on the fact that successValue can be chained\n\n```javascript\n\n   func1.wrapped(a, b, c)\n     .successValue(func2.wrapped(d, e, f))\n     .successValue(func3.wrapped(g, h, i))\n     .done(allDoneSuccessfully);\n\n    // you can do this in a loop if you are so inclined\n```  \n\n### Advanced features\n\n### get\n\nYou can fetch fields off of a promise and return a promise back.  The example is if you want a user's name but the user object itself needs to be fetched, you could do this:\n\n```javascript\n   \n   // Assume User.findById(id, done) returns a <user> object which has a Name property.\n\n   function getUserName(userId, done) {\n     User.findById.wrap(id)\n       .get('Name')\n       .done(done)\n      (); // this is needed to actually execute as useWith provides a lazy evaluation object\n   }\n```\n\n### useWith\n\nYou can use useWith to call functions on a promised value.  Example:\n\n```javascript\n\n   // Assume User.findById(id, done) returns a <user> object which has a getState method.\n   // To get the state of a user for id <userId>, you can do this:\n\n   function getUserState(userId, done) {\n     User.findById.wrap(id)\n       .useWith(function (cb) { return cb(null, this.getState()); })\n       .done(done)\n      (); // this is needed to actually execute as useWith provides a lazy evaluation object\n   }\n```\n\n### exec and execSync\n\nThe above example can also be made more readable by fetching the getState method and calling it. This is where exec comes in -- it can call a promise.\n\n```javascript\n\n   // Assume User.findById(id, done) returns a <user> object which has a getState method.\n   // To get the state of a user for id <userId>, you can do this:\n\n   function getUserState(userId, done) {\n     User.findById.wrap(id)\n       .get('getState')\n       .execSync() // we use execSync because the getState does not take a callback parameter\n       .done(done)\n      (); // this is needed to actually execute as useWith provides a lazy evaluation object\n   }\n```\n\nNote that you can pass parameters to exec and execSync and they get passed on to the base function.\n\n### method and methodSync\n\nThe above example can be simplified further via method which helps invoke methods easily.\n\n\n```javascript\n\n   // Assume User.findById(id, done) returns a <user> object which has a getState method.\n   // To get the state of a user for id <userId>, you can do this:\n\n   function getUserState(userId, done) {\n     User.findById.wrap(id)\n       .methodSync('getState') // you can pass parameters here if getState takes parameters\n       .done(done)\n      (); // this is needed to actually execute as useWith provides a lazy evaluation object\n   }\n```\n\n### lazy.js and underscore\n\nSometimes you want to pipe the output to lazyjs and or _ (depending on your library of choice).  This module does not depend on either of those modules but it provides a way to **apply** them.\n\nNote that all parameters passed to the lazyjs methods will automatically be lazy-evaluated, so you can pass a bunch of user objects that have not been fetched for example (i.e. you can pass wrapped functions with the confidence that by the time the underscore/lazy.js library is called, all its parameters will be fully evaluated).\n\n```javascript\n\n   function someAsyncFunction(x, y, done) {\n     return done(null, [x, y]);\n   }\n\n   someAsyncFunction.wrapped(1, 2).applyToSync(require('lazy.js') || require('underscore'))\n     .methodSync('map', function (x) { return {x: x, x2: x * x}; })\n     .methodSync('pluck', 'x2')\n     .methodSync('value')\n     .done(function (err, val) {\n        console.log(val); // val == [1*1, 2*2] now!\n     })\n     ();\n```",
  "_id": "syncwrap@0.0.10",
  "dist": {
    "shasum": "8b66997b5c5cbeef46699b43170f35bebc78180a"
  },
  "_from": "syncwrap@>=0.0.9",
  "_resolved": "https://registry.npmjs.org/syncwrap/-/syncwrap-0.0.10.tgz"
}
